name: Production Build, Publish and Release

on: 
  push:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      run_tests:
        description: 'Run tests job'
        required: false
        default: true
        type: boolean
      run_docker_tests:
        description: 'Run docker build tests'
        required: false
        default: true
        type: boolean
      run_build:
        description: 'Run build job'
        required: false
        default: true
        type: boolean
      run_docker_publish:
        description: 'Run docker publish'
        required: false
        default: true
        type: boolean
      run_pypi_publish:
        description: 'Run PyPI publish'
        required: false
        default: true
        type: boolean
      run_github_release:
        description: 'Run GitHub release'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  packages: write

env:
  DOCKER_IMAGE: akshaychikhalkar/carla-driving-simulator-client
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"

jobs:
  # ========================= TESTING PHASE =========================
  
  # Backend Tests - Carla Simulator
  test-carla-simulator:
    name: Test Carla Simulator
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event.inputs.run_tests == 'true'
    strategy:
      matrix:
        python-version: [3.11]
        test-path: ["carla_simulator/tests"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install pytest-cov pytest-html pytest-xdist

      - name: Run Carla Simulator tests
        run: |
          python -m pytest ${{ matrix.test-path }} \
            --cov=carla_simulator \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --html=reports/carla-simulator-test-report.html \
            --self-contained-html \
            -v \
            --tb=short
        env:
          TESTING: "true"
          DATABASE_URL: "sqlite:///:memory:"
          CONFIG_TENANT_ID: "1"

      - name: Upload Carla Simulator test coverage
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.xml
          flags: carla-simulator
          name: carla-simulator-coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload Carla Simulator test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: carla-simulator-test-results
          path: |
            reports/carla-simulator-test-report.html
            htmlcov/

  # Backend Tests - Web Backend
  test-web-backend:
    name: Test Web Backend
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event.inputs.run_tests == 'true'
    strategy:
      matrix:
        python-version: [3.11]
        test-path: ["web/backend/tests"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install pytest-cov pytest-html pytest-xdist

      - name: Run Web Backend tests
        run: |
          python -m pytest ${{ matrix.test-path }} \
            --cov=web.backend \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --html=reports/web-backend-test-report.html \
            --self-contained-html \
            -v \
            --tb=short
        env:
          TESTING: "true"
          WEB_FILE_LOGS_ENABLED: "false"
          DISABLE_AUTH_FOR_TESTING: "true"
          DATABASE_URL: "sqlite:///:memory:"
          CONFIG_TENANT_ID: "1"

      - name: Upload Web Backend test coverage
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.xml
          flags: web-backend
          name: web-backend-coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload Web Backend test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: web-backend-test-results
          path: |
            reports/web-backend-test-report.html
            htmlcov/

  # Frontend Tests
  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event.inputs.run_tests == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install frontend dependencies
        run: npm install
        working-directory: web/frontend

      - name: Run frontend tests
        run: npm run test:ci
        working-directory: web/frontend
        env:
          CI: true
          NODE_ENV: test

      - name: Upload frontend test coverage
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          slug: akshaychikhalkar/carla-driving-simulator-client
          flags: frontend
          name: frontend-coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload frontend test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-test-results
          path: web/frontend/coverage/

  # Integration Tests (if any)
  test-integration:
    name: Test Integration
    runs-on: ubuntu-latest
    needs: [test-carla-simulator, test-web-backend, test-frontend]
    if: always() && (github.event_name == 'push' || github.event.inputs.run_tests == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install pytest-cov pytest-html pytest-xdist

      - name: Run integration tests (if any)
        run: |
          # Check if there are any integration tests
          if [ -d "tests" ] && [ "$(ls -A tests)" ]; then
            python -m pytest tests \
              --cov=. \
              --cov-report=xml \
              --cov-report=html \
              --cov-report=term-missing \
              --html=reports/integration-test-report.html \
              --self-contained-html \
              -v \
              --tb=short
          else
            echo "No integration tests found - skipping"
            exit 0
          fi
        env:
          TESTING: "true"
          DATABASE_URL: "sqlite:///:memory:"
          CONFIG_TENANT_ID: "1"

      - name: Upload integration test coverage
        uses: codecov/codecov-action@v5
        if: success()
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.xml
          flags: integration
          name: integration-coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload integration test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: |
            reports/integration-test-report.html
            htmlcov/

  # Test Summary
  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [test-carla-simulator, test-web-backend, test-frontend, test-integration]
    if: always() && (github.event_name == 'push' || github.event.inputs.run_tests == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          path: test-results

      - name: Generate test summary
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check Carla Simulator tests
          if [ "${{ needs.test-carla-simulator.result }}" == "success" ]; then
            echo "✅ **Carla Simulator Tests**: PASSED" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Carla Simulator Tests**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check Web Backend tests
          if [ "${{ needs.test-web-backend.result }}" == "success" ]; then
            echo "✅ **Web Backend Tests**: PASSED" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Web Backend Tests**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check Frontend tests
          if [ "${{ needs.test-frontend.result }}" == "success" ]; then
            echo "✅ **Frontend Tests**: PASSED" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Frontend Tests**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check Integration tests
          if [ "${{ needs.test-integration.result }}" == "success" ]; then
            echo "✅ **Integration Tests**: PASSED" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.test-integration.result }}" == "skipped" ]; then
            echo "⏭️ **Integration Tests**: SKIPPED (no tests found)" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Integration Tests**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📊 **Coverage Reports**: Available in the artifacts" >> $GITHUB_STEP_SUMMARY
          echo "📋 **Test Reports**: Available in the artifacts" >> $GITHUB_STEP_SUMMARY

      - name: Fail if any tests failed
        if: |
          needs.test-carla-simulator.result != 'success' ||
          needs.test-web-backend.result != 'success' ||
          needs.test-frontend.result != 'success' ||
          (needs.test-integration.result != 'success' && needs.test-integration.result != 'skipped')
        run: |
          echo "❌ Some tests failed. Please check the test results above."
          exit 1

  # ========================= VERSION BUMP PHASE =========================
  
  version-bump:
    name: Bump version and create tag
    runs-on: ubuntu-latest
    needs: [test-summary]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && github.event.inputs.run_github_release == 'true'
    outputs:
      version: ${{ steps.bump_version.outputs.newTag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get current version
        id: current_version
        run: |
          # Get the latest version tag
          CURRENT_VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 2>/dev/null || echo "v1.0.0")
          # Remove 'v' prefix
          CURRENT_VERSION=${CURRENT_VERSION#v}
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Determine version bump type
        id: bump_type
        run: |
          # Get the last commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"
          
          # Determine bump type based on commit message
          if echo "$COMMIT_MSG" | grep -q "BREAKING CHANGE"; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
            echo "Bump type: major (breaking change detected)"
          elif echo "$COMMIT_MSG" | grep -q "^feat:"; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "Bump type: minor (feature detected)"
          elif echo "$COMMIT_MSG" | grep -q "^fix:"; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Bump type: patch (fix detected)"
          else
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Bump type: patch (default)"
          fi

      - name: Calculate new version
        id: bump_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Bump version based on type
          case $BUMP_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "newTag=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.newTag }}"
          TAG_NAME="v$NEW_VERSION"
          
          # Check if tag already exists
          if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "Tag $TAG_NAME already exists, skipping tag creation"
          else
            # Create tag
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
            echo "Created tag: $TAG_NAME"
            
            # Push tag
            git push origin "$TAG_NAME"
            echo "Pushed tag: $TAG_NAME"
          fi

      - name: Set build time
        id: build_time
        run: |
          BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "Build time: $BUILD_TIME"

  # ========================= BUILD PHASE =========================

  build-documentation:
    name: Build Documentation
    runs-on: ubuntu-latest
    needs: [test-summary]
    if: github.event_name == 'push' || github.event.inputs.run_build == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install sphinx sphinx-autodoc-typehints

      - name: Install Mermaid CLI
        run: npm install -g @mermaid-js/mermaid-cli

      - name: Run documentation automation
        run: |
          # Run the comprehensive documentation automation script
          # This handles: mmd generation, image conversion, API docs, and HTML build
          python docs/auto_generate_docs.py

      - name: Upload built docs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: html-docs
          path: docs/_build/html/

      - name: Upload documentation source
        uses: actions/upload-artifact@v4
        with:
          name: docs-source
          path: |
            docs/
            mmd/
            .readthedocs.yaml

  docker-build-test:
    name: Test Docker Builds and Save Images
    runs-on: ubuntu-latest
    needs: [test-summary, build-documentation]
    if: github.event_name == 'push' || github.event.inputs.run_docker_tests == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate Dockerfile existence
        run: |
          if [ ! -f "Dockerfile" ]; then
            echo "Error: Dockerfile not found"
            exit 1
          fi
          if [ ! -f "Dockerfile.dev" ]; then
            echo "Warning: Dockerfile.dev not found, skipping dev build test"
            echo "skip_dev_build=true" >> $GITHUB_ENV
          else
            echo "skip_dev_build=false" >> $GITHUB_ENV
          fi

      - name: Test Production Dockerfile
        run: |
          docker build -t test-prod \
            --build-arg VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev") \
            --build-arg DOCKER_IMAGE_TAG=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev") \
            --build-arg BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            .
          echo "Production Dockerfile builds successfully"

      - name: Test Development Dockerfile
        if: env.skip_dev_build != 'true'
        run: |
          docker build -f Dockerfile.dev -t test-dev \
            --build-arg VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev") \
            --build-arg DOCKER_IMAGE_TAG=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev") \
            --build-arg BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            .
          echo "Development Dockerfile builds successfully"
        env:
          skip_dev_build: ${{ env.skip_dev_build }}

      - name: Test Docker Compose
        run: |
          # Test docker compose build with build args
          VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev")
          BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          docker compose build --build-arg VERSION=$VERSION --build-arg DOCKER_IMAGE_TAG=$VERSION --build-arg BUILD_TIME=$BUILD_TIME
          echo "Docker Compose build successful"
          
          # Test docker compose config validation
          docker compose config
          echo "Docker Compose configuration is valid"
          
          # Test runtime validation (start services and check health)
          echo "Testing Docker Compose runtime validation..."
          docker compose up -d --timeout 60
          sleep 30  # Wait for services to start
          
          # Check if the main service is healthy
          if docker compose ps | grep -q "healthy"; then
            echo "✅ Docker Compose services are healthy"
          else
            echo "⚠️  Some services may not be healthy, but continuing..."
          fi
          
          # Stop services
          docker compose down
          echo "Docker Compose runtime validation completed"

  # ========================= PUBLISH PHASE =========================

  build-and-publish:
    name: Build and Publish
    runs-on: ubuntu-latest
    needs: [test-summary, build-documentation, docker-build-test]
    if: github.event_name == 'push' || github.event.inputs.run_build == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Build package
        run: python -m build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-package
          path: dist/

  publish-to-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [build-and-publish]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && github.event.inputs.run_pypi_publish == 'true'
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package
          path: dist/

      - name: Publish to PyPI
        run: |
          twine check dist/*
          twine upload --username ${{ secrets.PYPI_USERNAME }} --password ${{ secrets.PYPI_PASSWORD }} dist/*

  publish-docker:
    name: Publish Production Docker Images
    runs-on: ubuntu-latest
    needs: [build-and-publish]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && github.event.inputs.run_docker_publish == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push production image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:latest
            ${{ env.DOCKER_IMAGE }}:${{ needs.version-bump.outputs.version }}
            ${{ env.DOCKER_IMAGE }}:prod-${{ github.sha }}
          build-args: |
            VERSION=${{ needs.version-bump.outputs.version }}
            DOCKER_IMAGE_TAG=${{ needs.version-bump.outputs.version }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}
            ENVIRONMENT=production

  # ========================= RELEASE PHASE =========================

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [version-bump, publish-to-pypi, publish-docker]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && github.event.inputs.run_github_release == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.version-bump.outputs.version }}
          release_name: Release v${{ needs.version-bump.outputs.version }}
          body: |
            ## Release v${{ needs.version-bump.outputs.version }}
            
            ### Changes
            - Automated release from master branch
            
            ### Downloads
            - Docker images available on Docker Hub
            - Python package available on PyPI
            
            ### Test Results
            All tests passed successfully before release.
          draft: false
          prerelease: false

      - name: Download documentation artifacts
        uses: actions/download-artifact@v4
        with:
          name: html-docs
          path: docs-html

      - name: Upload release assets
        run: |
          # Upload test reports if available
          if [ -d "artifacts" ]; then
            for file in artifacts/*/reports/*.html; do
              if [ -f "$file" ]; then
                gh release upload v${{ needs.version-bump.outputs.version }} "$file" --clobber
              fi
            done
          fi
          
          # Upload documentation if available
          if [ -d "docs-html" ]; then
            echo "📚 Uploading documentation to release..."
            # Create a zip file of the documentation
            cd docs-html
            zip -r ../documentation.zip .
            cd ..
            gh release upload v${{ needs.version-bump.outputs.version }} documentation.zip --clobber
            echo "✅ Documentation uploaded successfully"
          fi 