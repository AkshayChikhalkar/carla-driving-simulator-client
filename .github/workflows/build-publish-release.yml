name: Production Build, Publish and Release

on: 
  push:
    branches: [ master ]
    paths:
      - 'carla_simulator/**'
      - 'web/**'
      - 'docs/**'
      - 'deployment/docker/**'
      - 'requirements/**'
      - 'pyproject.toml'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
      - '*.py'
      - 'package.json'
      - 'package-lock.json'
      - 'tests/**'
      - 'build-publish-release.yml'
  workflow_dispatch:
    inputs:
      run_tests:
        description: 'Run tests job'
        required: false
        default: true
        type: boolean
      run_build:
        description: 'Run build job'
        required: false
        default: true
        type: boolean
      run_publish:
        description: 'Run publish job'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  packages: write

env:
  DOCKER_IMAGE: akshaychikhalkar/carla-driving-simulator-client
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"

jobs:
  # ========================= TESTING MATRIX =========================
  
  test:
    name: Test ${{ matrix.test-suite }}
    runs-on: ubuntu-latest
    if: (github.event_name == 'push') || github.event.inputs.run_tests == 'true'
    strategy:
      matrix:
        test-suite: [carla-simulator, web-backend, frontend, integration]
        include:
          - test-suite: carla-simulator
            test-path: carla_simulator/tests
            cov-module: carla_simulator
            report-name: carla-simulator-test-report.html
            env-vars: "TESTING=true DATABASE_URL=sqlite:///:memory: CONFIG_TENANT_ID=1"
          - test-suite: web-backend
            test-path: web/backend/tests
            cov-module: web.backend
            report-name: web-backend-test-report.html
            env-vars: "TESTING=true WEB_FILE_LOGS_ENABLED=false DISABLE_AUTH_FOR_TESTING=true DATABASE_URL=sqlite:///:memory: CONFIG_TENANT_ID=1"
          - test-suite: frontend
            test-path: web/frontend
            cov-module: frontend
            report-name: frontend-test-report.html
            env-vars: "CI=true NODE_ENV=test"
          - test-suite: integration
            test-path: tests
            cov-module: integration
            report-name: integration-test-report.html
            env-vars: "TESTING=true DATABASE_URL=sqlite:///:memory: CONFIG_TENANT_ID=1"
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        if: matrix.test-suite != 'frontend'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: requirements/requirements.txt

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        if: matrix.test-suite == 'frontend'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: web/frontend/package-lock.json

      - name: Cache pip dependencies
        if: matrix.test-suite != 'frontend'
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        if: matrix.test-suite != 'frontend'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install pytest-cov pytest-html pytest-xdist

      - name: Install frontend dependencies
        if: matrix.test-suite == 'frontend'
        run: npm install
        working-directory: web/frontend

      - name: Cache npm dependencies
        if: matrix.test-suite == 'frontend'
        uses: actions/cache@v4
        with:
          path: |
            web/frontend/node_modules
            ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('web/frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Run ${{ matrix.test-suite }} tests
        if: matrix.test-suite != 'frontend' && matrix.test-suite != 'integration'
        run: |
          python -m pytest ${{ matrix.test-path }} \
            --cov=${{ matrix.cov-module }} \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --html=reports/${{ matrix.report-name }} \
            --self-contained-html \
            -v \
            --tb=short \
            --junitxml=reports/${{ matrix.test-suite }}-junit.xml
        env:
          TESTING: "true"
          DATABASE_URL: "sqlite:///:memory:"
          CONFIG_TENANT_ID: "1"
          WEB_FILE_LOGS_ENABLED: "false"
          DISABLE_AUTH_FOR_TESTING: "true"

      - name: Run frontend tests
        if: matrix.test-suite == 'frontend'
        run: |
          # Install dependencies if not already done
          npm install
          
          # Run tests with coverage and generate reports
          npm run test:ci
          
          # Create reports directory if it doesn't exist
          mkdir -p reports
          
          # Generate test report in HTML format
          if [ -f "coverage/lcov-report/index.html" ]; then
            cp coverage/lcov-report/index.html reports/frontend-test-report.html
          else
            echo "<html><body><h1>Frontend Test Report</h1><p>No coverage data available</p></body></html>" > reports/frontend-test-report.html
          fi
          
          # Generate JUnit XML report if available
          if [ -f "coverage/cobertura-coverage.xml" ]; then
            cp coverage/cobertura-coverage.xml reports/frontend-junit.xml
          else
            echo '<?xml version="1.0" encoding="UTF-8"?><testsuites><testsuite name="frontend" tests="0" failures="0" errors="0" skipped="0"></testsuite></testsuites>' > reports/frontend-junit.xml
          fi
          
          # Ensure coverage directory is in the right place
          if [ -d "coverage" ]; then
            echo "Coverage directory found:"
            ls -la coverage/
          else
            echo "No coverage directory found"
          fi
        working-directory: web/frontend
        env:
          CI: true
          NODE_ENV: test

      - name: Run integration tests
        if: matrix.test-suite == 'integration'
        run: |
          # Check if there are any integration tests
          if [ -d "tests" ] && [ "$(ls -A tests)" ]; then
            python -m pytest tests \
              --cov=. \
              --cov-report=xml \
              --cov-report=html \
              --cov-report=term-missing \
              --html=reports/${{ matrix.report-name }} \
              --self-contained-html \
              -v \
              --tb=short \
              --junitxml=reports/${{ matrix.test-suite }}-junit.xml
          else
            echo "No integration tests found - skipping"
            exit 0
          fi
        env:
          TESTING: "true"
          DATABASE_URL: "sqlite:///:memory:"
          CONFIG_TENANT_ID: "1"

      - name: Upload ${{ matrix.test-suite }} test coverage
        if: matrix.test-suite != 'integration' || success()
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.xml
          flags: ${{ matrix.test-suite }}
          name: ${{ matrix.test-suite }}-coverage

      - name: Upload ${{ matrix.test-suite }} test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ${{ matrix.test-suite }}-test-results
          path: |
            reports/${{ matrix.report-name }}
            reports/${{ matrix.test-suite }}-junit.xml
            coverage/
          if-no-files-found: warn

  # ========================= BUILD MATRIX =========================

  build:
    name: Build ${{ matrix.build-component }}
    runs-on: ubuntu-latest
    needs: [test, version-bump]
    if: (github.event_name == 'push') || github.event.inputs.run_build == 'true'
    strategy:
      matrix:
        build-component: [python-package, docker-image, documentation]
        include:
          - build-component: python-package
            description: "Python Package"
          - build-component: docker-image
            description: "Docker Image"
          - build-component: documentation
            description: "Documentation"
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        if: matrix.build-component != 'docker-image'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        if: matrix.build-component == 'documentation'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Set up Docker Buildx
        if: matrix.build-component == 'docker-image'
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:v0.12.0
          buildkitd-flags: --debug

      - name: Cache pip dependencies
        if: matrix.build-component != 'docker-image'
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-build-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-build-

      - name: Install Python dependencies
        if: matrix.build-component != 'docker-image'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install build setuptools wheel twine

      - name: Install Mermaid CLI
        if: matrix.build-component == 'documentation'
        run: npm install -g @mermaid-js/mermaid-cli

      - name: Build Python package
        if: matrix.build-component == 'python-package'
        run: |
          # Clean any existing builds
          rm -rf dist/ build/ *.egg-info/
          # Build package using modern build system
          python -m build

      - name: Build Docker image
        if: matrix.build-component == 'docker-image'
        run: |
          # Validate Dockerfile existence
          if [ ! -f "deployment/docker/Dockerfile" ]; then
            echo "Error: Dockerfile not found at deployment/docker/Dockerfile"
            exit 1
          fi
          
          # Use centralized version and build time
          VERSION="${{ needs.version-bump.outputs.version }}"
          DOCKER_TAG="${{ needs.version-bump.outputs.docker_tag }}"
          BUILD_TIME="${{ needs.version-bump.outputs.build_time }}"
          
          # Build Docker image with centralized values and optimized caching
          docker buildx build \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --cache-from type=registry,ref=${{ env.DOCKER_IMAGE }}:cache \
            --cache-to type=registry,ref=${{ env.DOCKER_IMAGE }}:cache,mode=max \
            -f deployment/docker/Dockerfile \
            -t ${{ env.DOCKER_IMAGE }}:$VERSION \
            --build-arg VERSION=$VERSION \
            --build-arg DOCKER_TAG=$DOCKER_TAG \
            --build-arg BUILD_TIME=$BUILD_TIME \
            --build-arg ENVIRONMENT=production \
            --load \
            --progress=plain \
            .
          
          echo "Docker image built successfully with version: $VERSION"

      - name: Build documentation
        if: matrix.build-component == 'documentation'
        run: |
          # Install required dependencies
          python -m pip install sphinx sphinx-rtd-theme
          
          # Install mermaid-cli if not available
          if ! command -v mmdc &> /dev/null; then
            npm install -g @mermaid-js/mermaid-cli
          fi
          
          # Run the comprehensive documentation automation script
          python docs/auto_generate_docs.py
          
          # Ensure the docs/_build/html directory exists
          mkdir -p docs/_build/html
          
          # If the script didn't generate HTML files, create a basic index
          if [ ! -f "docs/_build/html/index.html" ]; then
            echo "Creating basic documentation index..."
            echo '<!DOCTYPE html><html><head><title>CARLA Driving Simulator Client Documentation</title><meta charset="utf-8"><style>body{font-family:Arial,sans-serif;margin:40px}h1{color:#333}.container{max-width:800px;margin:0 auto}</style></head><body><div class="container"><h1>CARLA Driving Simulator Client Documentation</h1><p>Documentation is being generated. Please check back later.</p><p>For more information, see the project README and source code.</p></div></body></html>' > docs/_build/html/index.html
          fi
          
          echo "Documentation build completed. Files in docs/_build/html/:"
          ls -la docs/_build/html/ || echo "No files found"

      - name: Upload Python package artifact
        if: matrix.build-component == 'python-package'
        uses: actions/upload-artifact@v4
        with:
          name: python-package
          path: dist/

      - name: Save Docker image
        if: matrix.build-component == 'docker-image'
        run: |
          # Use centralized version
          VERSION="${{ needs.version-bump.outputs.version }}"
          docker save ${{ env.DOCKER_IMAGE }}:$VERSION | gzip > docker-image.tar.gz

      - name: Upload Docker image artifact
        if: matrix.build-component == 'docker-image'
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar.gz

      - name: Upload documentation artifact
        if: matrix.build-component == 'documentation'
        uses: actions/upload-artifact@v4
        with:
          name: html-docs
          path: docs/_build/html/
          if-no-files-found: warn

  # ========================= VERSION BUMP (Before build) =========================
  
  version-bump:
    name: Bump version and create tag
    runs-on: ubuntu-latest
    needs: [test]
    if: (github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_build == 'true')
    outputs:
      version: ${{ steps.bump_version.outputs.newTag }}
      tag_created: ${{ steps.create_tag.outputs.created }}
      docker_tag: ${{ steps.bump_version.outputs.dockerTag }}
      build_time: ${{ steps.build_time.outputs.buildTime }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get current version
        id: current_version
        run: |
          # Get the latest version tag
          CURRENT_VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 2>/dev/null || echo "v1.0.0")
          # Remove 'v' prefix
          CURRENT_VERSION=${CURRENT_VERSION#v}
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Determine version bump type
        id: bump_type
        run: |
          # Get the last commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"
          
          # Determine bump type based on commit message
          if echo "$COMMIT_MSG" | grep -q "BREAKING CHANGE"; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
            echo "Bump type: major (breaking change detected)"
          elif echo "$COMMIT_MSG" | grep -q "^feat:"; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "Bump type: minor (feature detected)"
          elif echo "$COMMIT_MSG" | grep -q "^fix:"; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Bump type: patch (fix detected)"
          else
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Bump type: patch (default)"
          fi

      - name: Calculate new version
        id: bump_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Bump version based on type
          case $BUMP_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          DOCKER_TAG="v$NEW_VERSION"
          echo "newTag=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "dockerTag=$DOCKER_TAG" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"
          echo "Docker tag: $DOCKER_TAG"

      - name: Create and push tag
        id: create_tag
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.newTag }}"
          TAG_NAME="v$NEW_VERSION"
          
          # Check if tag already exists
          if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "Tag $TAG_NAME already exists, skipping tag creation"
            echo "created=false" >> $GITHUB_OUTPUT
          else
            # Create tag
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
            echo "Created tag: $TAG_NAME"
            
            # Push tag
            git push origin "$TAG_NAME"
            echo "Pushed tag: $TAG_NAME"
            echo "created=true" >> $GITHUB_OUTPUT
          fi

      - name: Set build time
        id: build_time
        run: |
          BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "buildTime=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "Build time: $BUILD_TIME"

  # ========================= PUBLISH MATRIX =========================

  publish:
    name: Publish ${{ matrix.publish-target }}
    runs-on: ubuntu-latest
    needs: [build, version-bump]
    if: (github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_publish == 'true')
    strategy:
      matrix:
        publish-target: [pypi, docker, github-release]
        include:
          - publish-target: pypi
            description: "PyPI Package"
          - publish-target: docker
            description: "Docker Image"
          - publish-target: github-release
            description: "GitHub Release"
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        if: matrix.publish-target == 'pypi'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Docker Buildx
        if: matrix.publish-target == 'docker'
        uses: docker/setup-buildx-action@v3

      - name: Install build dependencies
        if: matrix.publish-target == 'pypi'
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Download Python package artifact
        if: matrix.publish-target == 'pypi'
        uses: actions/download-artifact@v4
        with:
          name: python-package
          path: dist/

      - name: Download Docker image artifact
        if: matrix.publish-target == 'docker'
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Download documentation artifact
        if: matrix.publish-target == 'github-release'
        uses: actions/download-artifact@v4
        with:
          name: html-docs
          path: docs-html
        continue-on-error: true

      - name: Download test results
        if: matrix.publish-target == 'github-release'
        uses: actions/download-artifact@v4
        with:
          path: test-results
        continue-on-error: true

      - name: Publish to PyPI
        if: matrix.publish-target == 'pypi'
        run: |
          # Verify PyPI token
          if [ -z "${{ secrets.PYPI_TOKEN }}" ]; then
            echo "Error: PYPI_TOKEN is not set"
            exit 1
          fi
          
          # Use centralized version
          VERSION="${{ needs.version-bump.outputs.version }}"
          echo "Publishing version: $VERSION"
          
          # Upload to PyPI
          python -m twine upload --skip-existing --verbose dist/*
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}

      - name: Publish to Docker Hub
        if: matrix.publish-target == 'docker'
        run: |
          # Check Docker credentials
          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ] || [ -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "‚ùå Docker Hub credentials not configured. Skipping Docker publish."
            exit 1
          fi
          
          # Login to Docker Hub
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin
          
          # Use centralized version and build time
          VERSION="${{ needs.version-bump.outputs.version }}"
          DOCKER_TAG="${{ needs.version-bump.outputs.docker_tag }}"
          
          # Load and tag Docker image
          gunzip -c docker-image.tar.gz | docker load
          docker tag ${{ env.DOCKER_IMAGE }}:$VERSION ${{ env.DOCKER_IMAGE }}:latest
          docker tag ${{ env.DOCKER_IMAGE }}:$VERSION ${{ env.DOCKER_IMAGE }}:$VERSION
          
          # Push to Docker Hub
          docker push ${{ env.DOCKER_IMAGE }}:latest
          docker push ${{ env.DOCKER_IMAGE }}:$VERSION
          
          echo "Docker image published successfully: $VERSION"

      - name: Create GitHub Release
        if: matrix.publish-target == 'github-release'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.version-bump.outputs.version }}
          name: Release v${{ needs.version-bump.outputs.version }}
          body: |
            ## Release v${{ needs.version-bump.outputs.version }}
            
            ### Changes
            - Automated release from master branch
            
            ### Downloads
            - Docker images available on Docker Hub
            - Python package available on PyPI
            
            ### Test Results
            All tests passed successfully before release.
          draft: false
          prerelease: false
          files: |
            test-results/*/reports/*.html
            documentation.zip

      - name: Upload release assets
        if: matrix.publish-target == 'github-release'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Upload test reports if available
          if [ -d "test-results" ]; then
            echo "üìä Uploading test reports to release..."
            for file in test-results/*/reports/*.html; do
              if [ -f "$file" ]; then
                echo "Uploading: $file"
                gh release upload v${{ needs.version-bump.outputs.version }} "$file" --clobber
              fi
            done
            echo "‚úÖ Test reports uploaded successfully"
          else
            echo "‚ö†Ô∏è No test results found to upload"
          fi
          
          # Upload documentation if available
          if [ -d "docs-html" ] && [ "$(ls -A docs-html)" ]; then
            echo "üìö Uploading documentation to release..."
            # Create a zip file of the documentation
            cd docs-html
            zip -r ../documentation.zip .
            cd ..
            gh release upload v${{ needs.version-bump.outputs.version }} documentation.zip --clobber
            echo "‚úÖ Documentation uploaded successfully"
          else
            echo "‚ö†Ô∏è No documentation found to upload"
          fi

  # ========================= CLEANUP ON FAILURE =========================

  cleanup-on-failure:
    name: Cleanup on failure
    runs-on: ubuntu-latest
    needs: [version-bump, publish]
    if: always() && (needs.version-bump.result == 'failure' || needs.publish.result == 'failure') && needs.version-bump.outputs.tag_created == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Remove created tag on failure
        run: |
          VERSION="${{ needs.version-bump.outputs.version }}"
          TAG_NAME="v$VERSION"
          
          echo "Workflow failed, removing tag: $TAG_NAME"
          
          # Delete tag locally
          git tag -d "$TAG_NAME" || echo "Tag not found locally"
          
          # Delete tag from remote
          git push origin ":refs/tags/$TAG_NAME" || echo "Tag not found on remote"
          
          echo "Tag $TAG_NAME removed successfully" 