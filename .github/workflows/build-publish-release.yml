name: Production Build, Publish and Release

on: 
  push:
    branches: [ master ]
    paths:
      - 'carla_simulator/**'
      - 'web/**'
      - 'docs/**'
      - 'deployment/docker/**'
      - 'requirements/**'
      - 'setup.py'
      - 'pyproject.toml'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
      - '*.py'
      - 'package.json'
      - 'package-lock.json'
      - 'tests/**'
      - 'build-publish-release.yml'
  workflow_dispatch:
    inputs:
      run_tests:
        description: 'Run tests job'
        required: false
        default: true
        type: boolean
      run_docker_tests:
        description: 'Run docker build tests'
        required: false
        default: true
        type: boolean
      run_build:
        description: 'Run build job'
        required: false
        default: true
        type: boolean
      run_docker_publish:
        description: 'Run docker publish'
        required: false
        default: true
        type: boolean
      run_pypi_publish:
        description: 'Run PyPI publish'
        required: false
        default: true
        type: boolean
      run_github_release:
        description: 'Run GitHub release'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  packages: write

env:
  DOCKER_IMAGE: akshaychikhalkar/carla-driving-simulator-client
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"

jobs:
  # ========================= TESTING PHASE =========================
  
  # Backend Tests - Combined Python Tests
  test-backend:
    name: Test Backend (Carla + Web)
    runs-on: ubuntu-latest
    if: (github.event_name == 'push') || github.event.inputs.run_tests == 'true'
    strategy:
      matrix:
        test-suite: [carla-simulator, web-backend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: requirements/requirements.txt

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install pytest-cov pytest-html pytest-xdist

      - name: Run ${{ matrix.test-suite }} tests
        run: |
          if [ "${{ matrix.test-suite }}" = "carla-simulator" ]; then
            TEST_PATH="carla_simulator/tests"
            COV_MODULE="carla_simulator"
            REPORT_NAME="carla-simulator-test-report.html"
            ENV_VARS="TESTING=true DATABASE_URL=sqlite:///:memory: CONFIG_TENANT_ID=1"
          else
            TEST_PATH="web/backend/tests"
            COV_MODULE="web.backend"
            REPORT_NAME="web-backend-test-report.html"
            ENV_VARS="TESTING=true WEB_FILE_LOGS_ENABLED=false DISABLE_AUTH_FOR_TESTING=true DATABASE_URL=sqlite:///:memory: CONFIG_TENANT_ID=1"
          fi
          
          python -m pytest $TEST_PATH \
            --cov=$COV_MODULE \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --html=reports/$REPORT_NAME \
            --self-contained-html \
            -v \
            --tb=short \
            --junitxml=reports/${{ matrix.test-suite }}-junit.xml
        env:
          TESTING: "true"
          DATABASE_URL: "sqlite:///:memory:"
          CONFIG_TENANT_ID: "1"
          WEB_FILE_LOGS_ENABLED: "false"
          DISABLE_AUTH_FOR_TESTING: "true"

      - name: Upload ${{ matrix.test-suite }} test coverage
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.xml
          flags: ${{ matrix.test-suite }}
          name: ${{ matrix.test-suite }}-coverage

      - name: Upload ${{ matrix.test-suite }} test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ${{ matrix.test-suite }}-test-results
          path: |
            reports/${{ matrix.test-suite }}-test-report.html
            reports/${{ matrix.test-suite }}-junit.xml
            htmlcov/

  # Frontend Tests
  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    if: (github.event_name == 'push') || github.event.inputs.run_tests == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: web/frontend/package-lock.json

      - name: Install frontend dependencies
        run: npm install
        working-directory: web/frontend

      - name: Run frontend tests
        run: npm run test:ci
        working-directory: web/frontend
        env:
          CI: true
          NODE_ENV: test

      - name: Upload frontend test coverage
        uses: codecov/codecov-action@v5
        with:
          files: web/frontend/coverage/lcov.info
          flags: frontend
          name: frontend-coverage

      - name: Upload frontend test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-test-results
          path: web/frontend/coverage/

  # Integration Tests (if any)
  test-integration:
    name: Test Integration
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    if: always() && (github.event_name == 'push' || github.event.inputs.run_tests == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: requirements/requirements.txt

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install pytest-cov pytest-html pytest-xdist

      - name: Run integration tests (if any)
        run: |
          # Check if there are any integration tests
          if [ -d "tests" ] && [ "$(ls -A tests)" ]; then
            python -m pytest tests \
              --cov=. \
              --cov-report=xml \
              --cov-report=html \
              --cov-report=term-missing \
              --html=reports/integration-test-report.html \
              --self-contained-html \
              -v \
              --tb=short \
              --junitxml=reports/integration-junit.xml
          else
            echo "No integration tests found - skipping"
            exit 0
          fi
        env:
          TESTING: "true"
          DATABASE_URL: "sqlite:///:memory:"
          CONFIG_TENANT_ID: "1"

      - name: Upload integration test coverage
        uses: codecov/codecov-action@v5
        if: success()
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.xml
          flags: integration
          name: integration-coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload integration test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: |
            reports/integration-test-report.html
            htmlcov/

  # Test Summary
  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend, test-integration]
    if: always() && (github.event_name == 'push' || github.event.inputs.run_tests == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          path: test-results

      - name: Generate test summary
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check Backend tests (matrix job)
          if [ "${{ needs.test-backend.result }}" == "success" ]; then
            echo "‚úÖ **Backend Tests (Carla + Web)**: PASSED" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Backend Tests (Carla + Web)**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check Frontend tests
          if [ "${{ needs.test-frontend.result }}" == "success" ]; then
            echo "‚úÖ **Frontend Tests**: PASSED" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Frontend Tests**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check Integration tests
          if [ "${{ needs.test-integration.result }}" == "success" ]; then
            echo "‚úÖ **Integration Tests**: PASSED" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.test-integration.result }}" == "skipped" ]; then
            echo "‚è≠Ô∏è **Integration Tests**: SKIPPED (no tests found)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Integration Tests**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìä **Coverage Reports**: Available in the artifacts" >> $GITHUB_STEP_SUMMARY
          echo "üìã **Test Reports**: Available in the artifacts" >> $GITHUB_STEP_SUMMARY

      - name: Fail if any tests failed
        if: |
          needs.test-backend.result != 'success' ||
          needs.test-frontend.result != 'success' ||
          (needs.test-integration.result != 'success' && needs.test-integration.result != 'skipped')
        run: |
          echo "‚ùå Some tests failed. Please check the test results above."
          exit 1

  # ========================= VERSION BUMP PHASE =========================
  
  version-bump:
    name: Bump version and create tag
    runs-on: ubuntu-latest
    needs: [test-summary]
    if: (github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_github_release == 'true')
    outputs:
      version: ${{ steps.bump_version.outputs.newTag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get current version
        id: current_version
        run: |
          # Get the latest version tag
          CURRENT_VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 2>/dev/null || echo "v1.0.0")
          # Remove 'v' prefix
          CURRENT_VERSION=${CURRENT_VERSION#v}
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Determine version bump type
        id: bump_type
        run: |
          # Get the last commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"
          
          # Determine bump type based on commit message
          if echo "$COMMIT_MSG" | grep -q "BREAKING CHANGE"; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
            echo "Bump type: major (breaking change detected)"
          elif echo "$COMMIT_MSG" | grep -q "^feat:"; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "Bump type: minor (feature detected)"
          elif echo "$COMMIT_MSG" | grep -q "^fix:"; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Bump type: patch (fix detected)"
          else
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Bump type: patch (default)"
          fi

      - name: Calculate new version
        id: bump_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Bump version based on type
          case $BUMP_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "newTag=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.newTag }}"
          TAG_NAME="v$NEW_VERSION"
          
          # Check if tag already exists
          if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "Tag $TAG_NAME already exists, skipping tag creation"
          else
            # Create tag
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
            echo "Created tag: $TAG_NAME"
            
            # Push tag
            git push origin "$TAG_NAME"
            echo "Pushed tag: $TAG_NAME"
          fi

      - name: Set build time
        id: build_time
        run: |
          BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "Build time: $BUILD_TIME"

  # ========================= BUILD PHASE =========================

  build-documentation:
    name: Build Documentation
    runs-on: ubuntu-latest
    needs: [test-summary]
    if: (github.event_name == 'push' && (contains(github.event.head_commit.modified, 'docs/') || contains(github.event.head_commit.added, 'docs/') || contains(github.event.head_commit.removed, 'docs/') || contains(github.event.head_commit.modified, 'carla_simulator/') || contains(github.event.head_commit.added, 'carla_simulator/') || contains(github.event.head_commit.removed, 'carla_simulator/'))) || github.event.inputs.run_build == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/requirements.txt
          pip install sphinx sphinx-autodoc-typehints

      - name: Install Mermaid CLI
        run: npm install -g @mermaid-js/mermaid-cli

      - name: Run documentation automation
        run: |
          # Run the comprehensive documentation automation script
          # This handles: mmd generation, image conversion, API docs, and HTML build
          python docs/auto_generate_docs.py

      - name: Upload built docs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: html-docs
          path: docs/_build/html/

      - name: Upload documentation source
        uses: actions/upload-artifact@v4
        with:
          name: docs-source
          path: |
            docs/
            mmd/
            .readthedocs.yaml

  docker-build-test:
    name: Test Docker Builds and Save Images
    runs-on: ubuntu-latest
    needs: [test-summary, build-documentation]
    if: (github.event_name == 'push' && (contains(github.event.head_commit.modified, 'deployment/docker/') || contains(github.event.head_commit.added, 'deployment/docker/') || contains(github.event.head_commit.removed, 'deployment/docker/') || contains(github.event.head_commit.modified, 'Dockerfile') || contains(github.event.head_commit.added, 'Dockerfile') || contains(github.event.head_commit.removed, 'Dockerfile') || contains(github.event.head_commit.modified, 'docker-compose') || contains(github.event.head_commit.added, 'docker-compose') || contains(github.event.head_commit.removed, 'docker-compose'))) || github.event.inputs.run_docker_tests == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate Dockerfile existence
        run: |
          if [ ! -f "deployment/docker/Dockerfile" ]; then
            echo "Error: Dockerfile not found at deployment/docker/Dockerfile"
            exit 1
          fi

      - name: Test Production Dockerfile
        run: |
          docker build -f deployment/docker/Dockerfile -t test-prod \
            --build-arg VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev") \
            --build-arg DOCKER_IMAGE_TAG=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev") \
            --build-arg BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            .
          echo "Production Dockerfile builds successfully"

      - name: Test Docker Compose
        if: contains(github.event.head_commit.modified, 'docker-compose') || contains(github.event.head_commit.added, 'docker-compose') || contains(github.event.head_commit.removed, 'docker-compose') || github.event.inputs.run_docker_tests == 'true'
        run: |
          # Change to docker directory where compose files are located
          cd deployment/docker
          
          # Test docker compose build with build args
          VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//' || echo "dev")
          BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          docker compose build --build-arg VERSION=$VERSION --build-arg DOCKER_IMAGE_TAG=$VERSION --build-arg BUILD_TIME=$BUILD_TIME
          echo "Docker Compose build successful"
          
          # Test docker compose config validation
          docker compose config
          echo "Docker Compose configuration is valid"
          
          # Test runtime validation (start services and check health)
          echo "Testing Docker Compose runtime validation..."
          docker compose up -d --timeout 60
          sleep 30  # Wait for services to start
          
          # Check if the main service is healthy
          if docker compose ps | grep -q "healthy"; then
            echo "‚úÖ Docker Compose services are healthy"
          else
            echo "‚ö†Ô∏è  Some services may not be healthy, but continuing..."
          fi
          
          # Stop services
          docker compose down
          echo "Docker Compose runtime validation completed"

  # ========================= PUBLISH PHASE =========================

  build-and-publish:
    name: Build and Publish
    runs-on: ubuntu-latest
    needs: [test-summary, build-documentation, docker-build-test, version-bump]
    if: github.event_name == 'push' || github.event.inputs.run_build == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-build-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-build-

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build setuptools wheel twine

      - name: Build package
        run: |
          # Clean any existing builds
          rm -rf dist/ build/ *.egg-info/
          # Update the version in the package
          VERSION="${{ needs.version-bump.outputs.version || 'dev' }}"
          echo "Building package version: $VERSION"
          # Update the __version__ in the package
          sed -i "s/__version__ = \".*\"/__version__ = \"$VERSION\"/" carla_simulator/__init__.py
          # Build package using modern build system
          python -m build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-package
          path: dist/

  publish-to-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [build-and-publish, version-bump]
    if: (github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_pypi_publish == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-publish-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-publish-

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build setuptools wheel twine

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package
          path: dist/

      - name: Verify PyPI token
        run: |
          echo "Checking PyPI token..."
          if [ -z "${{ secrets.PYPI_TOKEN }}" ]; then
            echo "Error: PYPI_TOKEN is not set"
            exit 1
          fi
          echo "PyPI token is set"

      - name: List files to upload
        run: ls -la dist/

      - name: Get version from Git tags
        id: get_version
        run: |
          VERSION=$(git describe --tags --match "v[0-9]*" --abbrev=0 | sed 's/^v//')
          # Fallback to git describe if no version tags exist
          if [ -z "$VERSION" ]; then
            VERSION=$(git describe --tags --always | sed 's/^v//' | sed 's/-.*$//')
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Publishing version: $VERSION"

      - name: Check if PyPI package already exists
        id: check_pypi
        run: |
          # Check if the specific version already exists on PyPI
          if python -m twine check dist/* | grep -q "PASSED"; then
            # Try to check if version exists (this is a simple check)
            echo "checking_pypi=true" >> $GITHUB_OUTPUT
            echo "PyPI package version ${{ steps.get_version.outputs.version }} will be checked during upload"
          else
            echo "checking_pypi=false" >> $GITHUB_OUTPUT
            echo "PyPI package validation failed"
          fi

      - name: Publish to PyPI
        if: steps.check_pypi.outputs.checking_pypi == 'true'
        run: |
          echo "Uploading to PyPI..."
          python -m twine upload --skip-existing --verbose dist/*
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}

  publish-docker:
    name: Publish Docker Images
    runs-on: ubuntu-latest
    needs: [build-and-publish, version-bump]
    if: (github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_docker_publish == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Check Docker credentials
        run: |
          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ] || [ -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "‚ùå Docker Hub credentials not configured. Skipping Docker publish."
            echo "Please set DOCKERHUB_USERNAME and DOCKERHUB_TOKEN secrets in repository settings."
            exit 1
          fi

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push production image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: deployment/docker/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:latest
            ${{ env.DOCKER_IMAGE }}:${{ needs.version-bump.outputs.version || 'dev' }}
          build-args: |
            VERSION=${{ needs.version-bump.outputs.version || 'dev' }}
            DOCKER_IMAGE_TAG=${{ needs.version-bump.outputs.version || 'dev' }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}
            ENVIRONMENT=production

  # ========================= RELEASE PHASE =========================

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [version-bump, publish-to-pypi, publish-docker]
    if: (github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_github_release == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.version-bump.outputs.version }}
          release_name: Release v${{ needs.version-bump.outputs.version }}
          body: |
            ## Release v${{ needs.version-bump.outputs.version }}
            
            ### Changes
            - Automated release from master branch
            
            ### Downloads
            - Docker images available on Docker Hub
            - Python package available on PyPI
            
            ### Test Results
            All tests passed successfully before release.
          draft: false
          prerelease: false

      - name: Download documentation artifacts
        uses: actions/download-artifact@v4
        with:
          name: html-docs
          path: docs-html

      - name: Upload release assets
        run: |
          # Upload test reports if available
          if [ -d "artifacts" ]; then
            for file in artifacts/*/reports/*.html; do
              if [ -f "$file" ]; then
                gh release upload v${{ needs.version-bump.outputs.version }} "$file" --clobber
              fi
            done
          fi
          
          # Upload documentation if available
          if [ -d "docs-html" ]; then
            echo "üìö Uploading documentation to release..."
            # Create a zip file of the documentation
            cd docs-html
            zip -r ../documentation.zip .
            cd ..
            gh release upload v${{ needs.version-bump.outputs.version }} documentation.zip --clobber
            echo "‚úÖ Documentation uploaded successfully"
          fi 